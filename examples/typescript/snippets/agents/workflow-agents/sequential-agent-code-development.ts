/**
 * TypeScript port of the Code Development Pipeline example from the Python ADK library
 * 
 * This example demonstrates creating a sequential agent workflow for code development
 * that coordinates multiple LLM agents to write, review, and refactor code.
 * 
 * NOTE: This is a template file that demonstrates how to use the ADK TypeScript library.
 * You'll see TypeScript errors in your IDE until you install the actual 'adk-typescript' package.
 * The structure and patterns shown here match how you would use the library in a real project.
 */

import { 
  LlmAgent, 
  SequentialAgent,
  Runner,
  LlmRegistry,
  Content,
  InMemorySessionService
} from 'adk-typescript';

// --- Constants ---
const APP_NAME = "code_pipeline_app";
const USER_ID = "dev_user_01";
const SESSION_ID = "pipeline_session_01";
const GEMINI_MODEL = "gemini-2.0-flash";

// Configure logging (simplified version for TypeScript)
const logger = {
  info: (message: string, ...args: any[]) => console.info(message, ...args),
  error: (message: string, ...args: any[]) => console.error(message, ...args)
};

// Create model instance (using LlmRegistry)
const model = LlmRegistry.newLlm(GEMINI_MODEL);

// --- 1. Define Sub-Agents for Each Pipeline Stage ---

// Code Writer Agent
// Takes the initial specification (from user query) and writes code.
const codeWriterAgent = new LlmAgent("CodeWriterAgent", {
  model: model,
  instruction: `You are a Code Writer AI.
  Based on the user's request, write the initial Python code.
  Output *only* the raw code block.
  `,
  description: "Writes initial code based on a specification.",
  // Stores its output (the generated code) into the session state
  // under the key 'generated_code'.
  outputKey: "generated_code"
});

// Code Reviewer Agent
// Takes the code generated by the previous agent (read from state) and provides feedback.
const codeReviewerAgent = new LlmAgent("CodeReviewerAgent", {
  model: model,
  instruction: `You are a Code Reviewer AI.
  Review the Python code provided in the session state under the key 'generated_code'.
  Provide constructive feedback on potential errors, style issues, or improvements.
  Focus on clarity and correctness.
  Output only the review comments.
  `,
  description: "Reviews code and provides feedback.",
  // Stores its output (the review comments) into the session state
  // under the key 'review_comments'.
  outputKey: "review_comments"
});

// Code Refactorer Agent
// Takes the original code and the review comments (read from state) and refactors the code.
const codeRefactorerAgent = new LlmAgent("CodeRefactorerAgent", {
  model: model,
  instruction: `You are a Code Refactorer AI.
  Take the original Python code provided in the session state key 'generated_code'
  and the review comments found in the session state key 'review_comments'.
  Refactor the original code to address the feedback and improve its quality.
  Output *only* the final, refactored code block.
  `,
  description: "Refactors code based on review comments.",
  // Stores its output (the refactored code) into the session state
  // under the key 'refactored_code'.
  outputKey: "refactored_code"
});

// --- 2. Create the SequentialAgent ---
// This agent orchestrates the pipeline by running the sub_agents in order.
const codePipelineAgent = new SequentialAgent("CodePipelineAgent");

// Add the sub-agents to the sequential agent in the order they should run
codeWriterAgent.setParentAgent(codePipelineAgent);
codeReviewerAgent.setParentAgent(codePipelineAgent);
codeRefactorerAgent.setParentAgent(codePipelineAgent);

// --- Setup Session and Runner ---
const sessionService = new InMemorySessionService();
const session = sessionService.createSession({
  appName: APP_NAME,
  userId: USER_ID,
  sessionId: SESSION_ID
});

logger.info(`Initial session state: ${JSON.stringify(session.state)}`);

const runner = new Runner({
  agent: codePipelineAgent,
  appName: APP_NAME,
  sessionService: sessionService
});

// --- Function to Interact with the Agent ---
function callAgent(query: string): void {
  // Create content for the request
  const content: Content = {
    role: 'user',
    parts: [{ text: query }]
  };

  // Run the agent and collect results
  let finalResponse = "No final response captured.";
  (async () => {
    try {
      const events = runner.run({
        userId: USER_ID, 
        sessionId: SESSION_ID, 
        newMessage: content
      });

      // Process events
      for await (const event of events) {
        if (event.isFinalResponse && event.content && event.content.parts && event.content.parts[0].text) {
          const responseText = event.content.parts[0].text || "";
          logger.info(`Final response from [${event.author}]: ${responseText}`);
          finalResponse = responseText;
        }
      }

      // Get the final session state
      const finalSession = sessionService.getSession({
        appName: APP_NAME,
        userId: USER_ID,
        sessionId: SESSION_ID
      });

      console.log("\n--- Agent Interaction Result ---");
      console.log("Agent Response: ", finalResponse);
      console.log("Final Session State:");
      console.log(JSON.stringify(finalSession?.state, null, 2));
      console.log("-------------------------------\n");
    } catch (error) {
      console.error("Error running agent:", error);
    }
  })();
}

// Run the agent with a sample query
callAgent("perform math addition");

// Export both the agent and the runner function for external use
export const agent = codePipelineAgent;
export function runCodePipeline(query: string): void {
  callAgent(query);
} 