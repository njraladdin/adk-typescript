/**
 * TypeScript port of the agent_cli.py example from the Python ADK library
 * 
 * This example demonstrates how to create a command-line interface for an
 * authenticated agent, handling OAuth flows in the console.
 * 
 * NOTE: This is a template file that demonstrates how to use the ADK TypeScript library.
 * You'll see TypeScript errors in your IDE until you install the actual 'adk-typescript' package.
 * The structure and patterns shown here match how you would use the library in a real project.
 */

import dotenv from 'dotenv';
import { 
  Runner, 
  InMemorySessionService,
  InMemoryArtifactService,
  Content,
  FunctionResponse,
  Part
} from 'adk-typescript';

import { 
  isPendingAuthEvent, 
  getFunctionCallId, 
  getFunctionCallAuthConfig,
  getUserInput 
} from './helpers';

import { agent } from './tools-and-agent';

// Load environment variables from .env file
dotenv.config();

/**
 * Main asynchronous function orchestrating the agent interaction and authentication flow.
 */
async function asyncMain(): Promise<void> {
  // --- Step 1: Service Initialization ---
  // Use in-memory services for session and artifact storage (suitable for demos/testing).
  const sessionService = new InMemorySessionService();
  const artifactsService = new InMemoryArtifactService();

  // Create a new user session to maintain conversation state.
  const session = sessionService.createSession({
    state: {},  // Optional state dictionary for session-specific data
    appName: 'my_app', // Application identifier
    userId: 'user' // User identifier
  });

  // --- Step 2: Initial User Query ---
  // Define the user's initial request.
  const query = 'Show me my user info';
  console.log(`user: ${query}`);

  // Format the query into the Content structure expected by the ADK Runner.
  const content: Content = {
    role: 'user',
    parts: [{ text: query }]
  };

  // Initialize the ADK Runner
  const runner = new Runner({
    appName: 'my_app',
    agent: agent,
    artifactService: artifactsService,
    sessionService: sessionService
  });

  // --- Step 3: Send Query and Handle Potential Auth Request ---
  console.log("\nRunning agent with initial query...");
  
  // Variables to store details if an authentication request occurs.
  let authRequestEventId: string | null = null;
  let authConfig = null;

  try {
    const events = runner.run({
      sessionId: session.id,
      userId: 'user',
      newMessage: content
    });

    // Iterate through the events generated by the first run.
    for await (const event of events) {
      // Check if this event is the specific 'adk_request_credential' function call.
      if (isPendingAuthEvent(event)) {
        console.log("--> Authentication required by agent.");
        authRequestEventId = getFunctionCallId(event);
        authConfig = getFunctionCallAuthConfig(event);
        // Once the auth request is found and processed, exit this loop.
        // We need to pause execution here to get user input for authentication.
        break;
      }
    }

    // If no authentication request was detected after processing all events, exit.
    if (!authRequestEventId || !authConfig) {
      console.log("\nAuthentication not required for this query or processing finished.");
      return; // Exit the main function
    }

    // --- Step 4: Manual Authentication Step (Simulated OAuth 2.0 Flow) ---
    // This section simulates the user interaction part of an OAuth 2.0 flow.
    // In a real web application, this would involve browser redirects.

    // Define the Redirect URI. This *must* match one of the URIs registered
    // with the OAuth provider for your application. The provider sends the user
    // back here after they approve the request.
    const redirectUri = 'http://localhost:8000/dev-ui'; // Example for local development

    // Construct the Authorization URL that the user must visit.
    // This typically includes the provider's authorization endpoint URL,
    // client ID, requested scopes, response type (e.g., 'code'), and the redirect URI.
    // Here, we retrieve the base authorization URI from the AuthConfig provided by ADK
    // and append the redirect_uri.
    // NOTE: A robust implementation would use urlencode and potentially add state, scope, etc.
    const authRequestUri = (
      authConfig.exchangedAuthCredential.oauth2.authUri +
      `&redirect_uri=${redirectUri}` // Simple concatenation; ensure correct query param format
    );

    console.log("\n--- User Action Required ---");
    // Prompt the user to visit the authorization URL, log in, grant permissions,
    // and then paste the *full* URL they are redirected back to (which contains the auth code).
    const authResponseUri = await getUserInput(
      `1. Please open this URL in your browser to log in:\n   ${authRequestUri}\n\n` +
      `2. After successful login and authorization, your browser will be redirected.\n` +
      `   Copy the *entire* URL from the browser's address bar.\n\n` +
      `3. Paste the copied URL here and press Enter:\n\n> `
    );

    // --- Step 5: Prepare Authentication Response for the Agent ---
    // Update the AuthConfig object with the information gathered from the user.
    // The ADK framework needs the full response URI (containing the code)
    // and the original redirect URI to complete the OAuth token exchange process internally.
    authConfig.exchangedAuthCredential.oauth2.authResponseUri = authResponseUri;
    authConfig.exchangedAuthCredential.oauth2.redirectUri = redirectUri;

    // Construct a FunctionResponse Content object to send back to the agent/runner.
    // This response explicitly targets the 'adk_request_credential' function call
    // identified earlier by its ID.
    const authContent: Content = {
      role: 'user',
      parts: [
        {
          functionResponse: {
            // Crucially, link this response to the original request using the saved ID.
            id: authRequestEventId,
            // The special name of the function call we are responding to.
            name: 'adk_request_credential',
            // The payload containing all necessary authentication details.
            response: authConfig.toJSON()
          } as FunctionResponse
        } as Part
      ]
    };

    // --- Step 6: Resume Execution with Authentication ---
    console.log("\nSubmitting authentication details back to the agent...");
    // Run the agent again, this time providing the `authContent` (FunctionResponse).
    // The ADK Runner intercepts this, processes the 'adk_request_credential' response
    // (performs token exchange, stores credentials), and then allows the agent
    // to retry the original tool call that required authentication, now succeeding with
    // a valid access token embedded.
    const authEvents = runner.run({
      sessionId: session.id,
      userId: 'user',
      newMessage: authContent // Provide the prepared auth response
    });

    // Process and print the final events from the agent after authentication is complete.
    // This stream now contain the actual result from the tool (e.g., the user info).
    console.log("\n--- Agent Response after Authentication ---");
    for await (const event of authEvents) {
      console.log(event);
    }
  } catch (error) {
    console.error(`Error in main function: ${error}`);
  }
}

// Execute the main function if this module is run directly
if (require.main === module) {
  asyncMain().catch(error => {
    console.error(`Unhandled error in main: ${error}`);
  });
}

// Export for external use
export { asyncMain as runAuthenticatedDemo }; 