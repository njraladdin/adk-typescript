import dotenv from 'dotenv';
import { runners } from 'adk-typescript';
import { Content, Part } from 'adk-typescript/types';
import { InMemorySessionService } from 'adk-typescript/sessions';
import { InMemoryArtifactService } from 'adk-typescript/artifacts';
import { AuthConfig } from 'adk-typescript/auth';

import { 
  isPendingAuthEvent, 
  getFunctionCallId, 
  getFunctionCallAuthConfig,
  getUserInput 
} from './helpers';

import { agent } from './ToolsAndAgent';

// Load environment variables from .env file
dotenv.config();

/**
 * Interface for Function Response in ADK
 */
interface FunctionResponse {
  id: string;
  name: string;
  response: any;
}

/**
 * Main asynchronous function orchestrating the agent interaction and authentication flow.
 */
async function asyncMain(): Promise<void> {
  // --- Step 1: Service Initialization ---
  // Use in-memory services for session and artifact storage (suitable for demos/testing).
  const sessionService = new InMemorySessionService();
  const artifactsService = new InMemoryArtifactService();

  // Create a new user session to maintain conversation state.
  const session = sessionService.createSession({
    state: {},  // Optional state dictionary for session-specific data
    appName: 'my_app', // Application identifier
    userId: 'user' // User identifier
  });

  // --- Step 2: Initial User Query ---
  // Define the user's initial request.
  const query = 'Show me my user info';
  console.log(`user: ${query}`);

  // Format the query into the Content structure expected by the ADK Runner.
  const content: Content = {
    role: 'user',
    parts: [{ text: query }]
  };

  // Initialize the ADK Runner
  const runner = new runners.Runner({
    appName: 'my_app',
    agent: agent,
    artifactService: artifactsService,
    sessionService: sessionService
  });

  // --- Step 3: Send Query and Handle Potential Auth Request ---
  console.log("\nRunning agent with initial query...");
  
  // Variables to store details if an authentication request occurs.
  let authRequestEventId: string | null = null;
  let authConfig: AuthConfig | null = null;

  try {
    const session = await sessionService.createSession({
      state: {},  // Optional state dictionary for session-specific data
      appName: 'my_app', // Application identifier
      userId: 'user' // User identifier
    });
    const events = runner.run({
      sessionId: session.id,
      userId: 'user',
      newMessage: content
    });

    // Iterate through the events generated by the first run.
    for await (const event of events) {
      // Check if this event is the specific 'adk_request_credential' function call.
      if (isPendingAuthEvent(event)) {
        console.log("--> Authentication required by agent.");
        authRequestEventId = getFunctionCallId(event);
        authConfig = getFunctionCallAuthConfig(event);
        // Once the auth request is found and processed, exit this loop.
        // We need to pause execution here to get user input for authentication.
        break;
      }
    }

    // If no authentication request was detected after processing all events, exit.
    if (!authRequestEventId || !authConfig) {
      console.log("\nAuthentication not required for this query or processing finished.");
      return; // Exit the main function
    }

    // --- Step 4: Manual Authentication Step (Simulated OAuth 2.0 Flow) ---
    // This section simulates the user interaction part of an OAuth 2.0 flow.
    // In a real web application, this would involve browser redirects.

    // Define the Redirect URI. This *must* match one of the URIs registered
    // with the OAuth provider for your application. The provider sends the user
    // back here after they approve the request.
    const redirectUri = 'http://localhost:8000/dev-ui'; // Example for local development

    // Construct the Authorization URL that the user must visit.
    // This typically includes the provider's authorization endpoint URL,
    // client ID, requested scopes, response type (e.g., 'code'), and the redirect URI.
    // Here, we retrieve the base authorization URI from the AuthConfig provided by ADK
    // and append the redirect_uri.
    // NOTE: A robust implementation would use urlencode and potentially add state, scope, etc.
    const authRequestUri = (
      authConfig.exchangedAuthCredential?.oauth2?.auth_uri +
      `&redirect_uri=${redirectUri}` // Simple concatenation; ensure correct query param format
    );

    console.log("\n--- User Action Required ---");
    // Prompt the user to visit the authorization URL, log in, grant permissions,
    // and then paste the *full* URL they are redirected back to (which contains the auth code).
    const authResponseUri = await getUserInput(
      `1. Please open this URL in your browser to log in:\n   ${authRequestUri}\n\n` +
      `2. After successful login and authorization, your browser will be redirected.\n` +
      `   Copy the *entire* URL from the browser's address bar.\n\n` +
      `3. Paste the copied URL here and press Enter:\n\n> `
    );

    // --- Step 5: Prepare Authentication Response for the Agent ---
    // Update the AuthConfig object with the information gathered from the user.
    // The ADK framework needs the full response URI (containing the code)
    // and the original redirect URI to complete the OAuth token exchange process internally.
    if (authConfig.exchangedAuthCredential?.oauth2) {
      authConfig.exchangedAuthCredential.oauth2.auth_response_uri = authResponseUri;
      authConfig.exchangedAuthCredential.oauth2.redirect_uri = redirectUri;
    }

    // Construct a FunctionResponse Content object to send back to the agent/runner.
    // This response explicitly targets the 'adk_request_credential' function call
    // identified earlier by its ID.
    const authContent: Content = {
      role: 'user',
      parts: [
        {
          functionResponse: {
            // Crucially, link this response to the original request using the saved ID.
            id: authRequestEventId,
            // The special name of the function call we are responding to.
            name: 'adk_request_credential',
            // The payload containing all necessary authentication details.
            response: authConfig
          } as FunctionResponse
        } as Part
      ]
    };

    // --- Step 6: Resume Execution with Authentication ---
    console.log("\nSubmitting authentication details back to the agent...");
    // Run the agent again, this time providing the `authContent` (FunctionResponse).
    // The ADK Runner intercepts this, processes the 'adk_request_credential' response
    // (performs token exchange, stores credentials), and then allows the agent
    // to retry the original tool call that required authentication, now succeeding with
    // a valid access token embedded.
    const authEvents = runner.run({
      sessionId: session.id,
      userId: 'user',
      newMessage: authContent // Provide the prepared auth response
    });

    // Process and print the final events from the agent after authentication is complete.
    // This stream now contain the actual result from the tool (e.g., the user info).
    console.log("\n--- Agent Response after Authentication ---");
    for await (const event of authEvents) {
      console.log(event);
    }
  } catch (error) {
    console.error(`Error in main function: ${error}`);
  }
}

// Execute the main function if this module is run directly
if (require.main === module) {
  asyncMain().catch(error => {
    console.error(`Unhandled error in main: ${error}`);
  });
}

// Export for external use
export { asyncMain as runAuthenticatedDemo }; 