import { LlmAgent as Agent } from '../../../src';
import { Runner } from '../../../src/runners';
import { BaseAgent } from '../../../src/agents/BaseAgent';
import { BaseArtifactService } from '../../../src/artifacts/BaseArtifactService';
import { InMemoryArtifactService } from '../../../src/artifacts/InMemoryArtifactService';
import { BaseSessionService } from '../../../src/sessions/baseSessionService';
import { InMemorySessionService } from '../../../src/sessions/inMemorySessionService';
import { Session } from '../../../src/sessions/interfaces';
import { Event } from '../../../src/events/Event';

/**
 * TestRunner class used for testing agents in the integration tests
 */
export class TestRunner {
  private agent: Agent | BaseAgent;
  private agentClient: Runner;
  private sessionService: BaseSessionService;
  private currentSessionId: string;
  private readonly appName = "test_app";
  private readonly userId = "test_user";

  /**
   * Create a new TestRunner instance
   * @param agent The agent to test
   * @param artifactService Optional artifact service for storing artifacts
   * @param sessionService Optional session service for managing sessions
   */
  constructor(
    agent: Agent | BaseAgent,
    artifactService: BaseArtifactService = new InMemoryArtifactService(),
    sessionService: BaseSessionService = new InMemorySessionService(),
  ) {
    this.agent = agent;
    // We need to cast the Agent to BaseAgent since Runner expects BaseAgent
    // In a real implementation, Agent would likely extend BaseAgent
    this.agentClient = new Runner({
      appName: this.appName,
      agent: agent as BaseAgent,
      artifactService: artifactService,
      sessionService: sessionService,
    });
    this.sessionService = sessionService;
    
    // Create the initial session and handle async session creation
    const sessionPromise = this.sessionService.createSession({
      appName: this.appName,
      userId: this.userId
    });
    
    // Handle both synchronous and Promise-based session services
    if (sessionPromise instanceof Promise) {
      sessionPromise.then(session => {
        this.currentSessionId = session.id;
      });
      // Set a temporary ID that will be overwritten when the promise resolves
      this.currentSessionId = 'initializing';
    } else {
      this.currentSessionId = sessionPromise.id;
    }
  }

  /**
   * Create a new session
   * @param sessionId Optional session ID
   */
  async newSession(sessionId?: string): Promise<void> {
    const sessionPromise = this.sessionService.createSession({
      appName: this.appName,
      userId: this.userId,
      sessionId: sessionId
    });
    
    // Handle both synchronous and Promise-based session services
    if (sessionPromise instanceof Promise) {
      const session = await sessionPromise;
      this.currentSessionId = session.id;
    } else {
      this.currentSessionId = sessionPromise.id;
    }
  }

  /**
   * Run a prompt through the agent
   * @param prompt The prompt to send to the agent
   * @returns List of events generated by the agent
   */
  async run(prompt: string): Promise<any[]> {
    const currentSession = await this.getCurrentSession();
    if (!currentSession) {
      throw new Error("No current session");
    }

    const events: any[] = [];
    // Convert to an async iterator/generator
    const eventGenerator = this.agentClient.run({
      userId: currentSession.userId,
      sessionId: currentSession.id,
      newMessage: {
        role: "user",
        parts: [{ text: prompt }]
      }
    });

    // Process all events from the generator
    for await (const event of eventGenerator) {
      events.push(event);
    }

    return events;
  }

  /**
   * Get the current session
   * @returns The current session or undefined if not found
   */
  async getCurrentSession(): Promise<Session | undefined> {
    const sessionPromise = this.sessionService.getSession({
      appName: this.appName,
      userId: this.userId,
      sessionId: this.currentSessionId
    });
    
    // Handle both synchronous and Promise-based session services
    if (sessionPromise instanceof Promise) {
      const result = await sessionPromise;
      return result || undefined;
    }
    return sessionPromise || undefined;
  }

  /**
   * Get all events recorded for the current session
   * @returns Array of events
   */
  async getEvents(): Promise<any[]> {
    const session = await this.getCurrentSession();
    return session ? session.events : [];
  }

  /**
   * Get the name of the current agent being used
   * @returns The agent name
   */
  async getCurrentAgentName(): Promise<string> {
    const session = await this.getCurrentSession();
    if (!session) {
      throw new Error("No current session");
    }
    // Use type assertion to pass the session to findAgentToRun
    return this.agentClient['_findAgentToRun'](session as any, this.agent as BaseAgent).name;
  }

  /**
   * Create a TestRunner from an agent name
   * @param agentName The name of the agent to test
   * @returns A new TestRunner instance
   */
  static fromAgentName(agentName: string): TestRunner {
    // Import the agent module dynamically
    try {
      // This is an approximation of the Python importlib.import_module
      // In TypeScript we'd need to use dynamic import or have a registry of agents
      const agentPath = `../fixture/${agentName}`;
      // Note: This is a placeholder. In an actual implementation, you'd need to
      // dynamically load the module and get the agent from it
      const agent = require(agentPath).agent.root_agent;
      return new TestRunner(agent);
    } catch (error) {
      throw new Error(`Loading agents by name failed: ${error}`);
    }
  }
} 