import { v4 as uuidv4 } from 'uuid';
import { BaseAgent } from './agents/BaseAgent';
import { InvocationContext } from './agents/InvocationContext';
import { LlmAgent } from './agents/LlmAgent';
import { LiveRequestQueue } from './agents/LiveRequestQueue';
import { RunConfig } from './agents/RunConfig';
import { ActiveStreamingTool } from './agents/ActiveStreamingTool';
import { BaseArtifactService } from './artifacts/BaseArtifactService';
import { InMemoryArtifactService } from './artifacts/InMemoryArtifactService';
import { Event } from './events/Event';
import { BaseMemoryService } from './memory/BaseMemoryService';
import { InMemoryMemoryService } from './memory/InMemoryMemoryService';
import { Content } from './models/types';
import { BaseLlm } from './models/BaseLlm';
import { BaseSessionService } from './sessions/BaseSessionService';
import { InMemorySessionService } from './sessions/InMemorySessionService';
import { Session } from './sessions/Session';
import { tracer } from './telemetry';
import { BuiltInCodeExecutionTool } from './tools/BuiltInCodeExecutionTool';
import { ReadonlyContext } from './agents/ReadonlyContext';

// Logger is a placeholder - implement with proper logging library
const logger = {
  warning: (message: string, ...args: any[]) => console.warn(message, ...args),
  info: (message: string, ...args: any[]) => console.info(message, ...args),
  error: (message: string, ...args: any[]) => console.error(message, ...args)
};

/**
 * The Runner class is used to run agents.
 *
 * It manages the execution of an agent within a session, handling message
 * processing, event generation, and interaction with various services like
 * artifact storage, session management, and memory.
 */
export class Runner {
  /**
   * The application name of the runner.
   */
  appName: string;

  /**
   * The root agent to run.
   */
  agent: BaseAgent;

  /**
   * The artifact service for the runner.
   */
  artifactService?: BaseArtifactService;

  /**
   * The session service for the runner.
   */
  sessionService: BaseSessionService;

  /**
   * The memory service for the runner.
   */
  memoryService?: BaseMemoryService;

  /**
   * Initializes the Runner.
   *
   * @param params The parameters for the runner.
   * @param params.appName The application name of the runner.
   * @param params.agent The root agent to run.
   * @param params.artifactService The artifact service for the runner.
   * @param params.sessionService The session service for the runner.
   * @param params.memoryService The memory service for the runner.
   */
  constructor(params: {
    appName: string;
    agent: BaseAgent;
    artifactService?: BaseArtifactService;
    sessionService: BaseSessionService;
    memoryService?: BaseMemoryService;
  }) {
    this.appName = params.appName;
    this.agent = params.agent;
    this.artifactService = params.artifactService;
    this.sessionService = params.sessionService;
    this.memoryService = params.memoryService;
  }

  /**
   * Runs the agent.
   *
   * NOTE: This sync interface is only for local testing and convenience purpose.
   * Consider using `runAsync` for production usage.
   *
   * @param params The parameters for the run.
   * @param params.userId The user ID of the session.
   * @param params.sessionId The session ID of the session.
   * @param params.newMessage A new message to append to the session.
   * @param params.runConfig The run config for the agent.
   * @returns A generator that yields the events generated by the agent.
   */
  async *run(params: {
    userId: string;
    sessionId: string;
    newMessage: Content;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, unknown> {
    const { userId, sessionId, newMessage, runConfig } = params;
    
    // Get or create session
    let session = await this.sessionService.getSession({
      appName: this.appName,
      userId: userId,
      sessionId: sessionId
    });
    
    if (!session) {
      session = await this.sessionService.createSession({
        appName: this.appName,
        userId: userId,
        sessionId: sessionId
      });
    }
    
    // Create invocation context
    const invocationContext = await this._newInvocationContext({
      session: session as any,
      newMessage,
      runConfig
    });
    
    // Append user message to session
    await this._appendNewMessageToSession({
      session: session as any,
      newMessage,
      invocationContext,
      saveInputBlobsAsArtifacts: true
    });
    
    // Find the appropriate agent to run
    const agentToRun = this._findAgentToRun(session as any, this.agent);
    
    // Run the agent
    yield* agentToRun.invoke(invocationContext);
  }

  /**
   * Main entry method to run the agent in this runner.
   *
   * @param params The parameters for the run.
   * @param params.userId The user ID of the session.
   * @param params.sessionId The session ID of the session.
   * @param params.newMessage A new message to append to the session.
   * @param params.runConfig The run config for the agent.
   * @returns An async generator that yields events generated by the agent.
   */
  async *runAsync(params: {
    userId: string;
    sessionId: string;
    newMessage: Content;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, unknown> {
    const { userId, sessionId, newMessage, runConfig } = params;
    
    // Get or create session
    let session = await this.sessionService.getSession({
      appName: this.appName,
      userId: userId,
      sessionId: sessionId
    });
    
    if (!session) {
      session = await this.sessionService.createSession({
        appName: this.appName,
        userId: userId,
        sessionId: sessionId
      });
    }
    
    // Create invocation context
    const invocationContext = await this._newInvocationContext({
      session: session as any,
      newMessage,
      runConfig
    });
    
    // Append user message to session
    await this._appendNewMessageToSession({
      session: session as any,
      newMessage,
      invocationContext,
      saveInputBlobsAsArtifacts: true
    });
    
    // Find the appropriate agent to run
    const agentToRun = this._findAgentToRun(session as any, this.agent);
    
    // Run the agent asynchronously
    yield* agentToRun.runAsync(invocationContext);
  }

  /**
   * Appends a new message to a session.
   *
   * @param params The parameters for appending a message.
   * @param params.session The session to append to.
   * @param params.newMessage The message to append.
   * @param params.invocationContext The invocation context.
   * @param params.saveInputBlobsAsArtifacts Whether to save input blobs as artifacts.
   * @private
   */
  private async _appendNewMessageToSession(params: {
    session: Session;
    newMessage: Content;
    invocationContext: InvocationContext;
    saveInputBlobsAsArtifacts?: boolean;
  }): Promise<void> {
    const { session, newMessage, invocationContext, saveInputBlobsAsArtifacts = false } = params;

    if (this.artifactService && saveInputBlobsAsArtifacts) {
      // The runner directly saves the artifacts (if applicable) in the
      // user message and replaces the artifact data with a file name
      // placeholder.
      for (let i = 0; i < newMessage.parts.length; i++) {
        const part = newMessage.parts[i];
        if (!part.inlineData) {
          continue;
        }
        const fileName = `artifact_${invocationContext.invocationId}_${i}`;
        try {
          await this.artifactService.saveArtifact({
            appName: this.appName,
            userId: session.userId,
            sessionId: session.id,
            filename: fileName,
            artifact: part
          });
          
          newMessage.parts[i] = {
            text: `Uploaded file: ${fileName}. It is saved into artifacts`
          };
        } catch (error) {
          console.error('Error saving artifact:', error);
          // Continue with the message even if saving artifact fails
        }
      }
    }
    
    // Appends only. We do not yield the event because it's not from the model.
    const event = new Event({
      invocationId: invocationContext.invocationId,
      author: 'user',
      content: newMessage
    });
    
    await this.sessionService.appendEvent({
      session: session as any,
      event: event as any
    });
  }

  /**
   * Runs the agent in live mode.
   *
   * @param params The parameters for live mode.
   * @param params.session The session to use.
   * @param params.liveRequestQueue The queue for live requests.
   * @param params.runConfig The run config for the agent.
   * @returns An async generator of events.
   *
   * @experimental This feature is **experimental** and its API or behavior may change
   *               in future releases.
   */
  async *runLive(params: {
    session: Session;
    liveRequestQueue: LiveRequestQueue;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, unknown> {
    const { session, liveRequestQueue, runConfig } = params;
    
    // Create invocation context
    const invocationContext = await this._newInvocationContextForLive({
      session,
      liveRequestQueue,
      runConfig
    });
    
    // Find the appropriate agent to run
    const agentToRun = this._findAgentToRun(session, this.agent);
    
    // Run the agent live
    yield* agentToRun.runLive(invocationContext);
  }

  /**
   * Closes a session and adds it to the memory service (experimental feature).
   * 
   * @param session The session to close
   */
  async closeSession(session: Session): Promise<void> {
    if (this.memoryService) {
      await this.memoryService.addSessionToMemory(session as any);
    }
    await this.sessionService.closeSession({
      session: session as any
    });
  }

  /**
   * Finds the agent to run to continue the session.
   *
   * A qualified agent must be either of:
   * - The root agent;
   * - An LlmAgent who replied last and is capable to transfer to any other agent
   *   in the agent hierarchy.
   *
   * @param session The session to find the agent for.
   * @param rootAgent The root agent of the runner.
   * @returns The agent of the last message in the session or the root agent.
   * @private
   */
  private _findAgentToRun(session: Session, rootAgent: BaseAgent): BaseAgent {
    // Make sure session has required properties
    if (!session.agents) {
      session.agents = new Map();
    }
    
    // Make sure the root agent is registered in the session
    if (!session.agents.has(rootAgent.name)) {
      session.agents.set(rootAgent.name, rootAgent);
    }
    
    // Add getAgent method if not present
    if (!session.getAgent) {
      session.getAgent = function(name: string): BaseAgent | undefined {
        return this.agents.get(name);
      };
    }
    
    // Filter for non-user events and process them in reverse order
    const nonUserEvents = session.events.filter(e => e.author !== 'user');
    
    for (let i = nonUserEvents.length - 1; i >= 0; i--) {
      const event = nonUserEvents[i];
      
      if (event.author === rootAgent.name) {
        // Found root agent
        return rootAgent;
      }
      
      const agent = rootAgent.findSubAgent(event.author);
      if (!agent) {
        // Agent not found, continue looking
        logger.warning(
          `Event from an unknown agent: ${event.author}, event id: ${event.id}`
        );
        continue;
      }
      
      if (this._isTransferableAcrossAgentTree(agent)) {
        return agent;
      }
    }
    
    // Falls back to root agent if no suitable agents are found in the session
    return rootAgent;
  }

  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * This typically means all agent_to_run's parent through root agent can
   * transfer to their parent_agent.
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   * @private
   */
  private _isTransferableAcrossAgentTree(agentToRun: BaseAgent): boolean {
    let agent: BaseAgent | undefined = agentToRun;
    
    while (agent) {
      if (!(agent instanceof LlmAgent)) {
        // Only LLM-based Agent can provide agent transfer capability
        return false;
      }
      
      const llmAgent = agent as LlmAgent;
      // Check if transfers to peers are allowed - in TypeScript we use disallowTransferToPeers
      if (llmAgent.disallowTransferToPeers === true) {
        return false;
      }
      
      agent = agent.parentAgent;
    }
    
    return true;
  }

  /**
   * Creates a new invocation context.
   *
   * @param params The parameters for the invocation context.
   * @param params.session The session for the context.
   * @param params.newMessage The new message for the context.
   * @param params.liveRequestQueue The live request queue for the context.
   * @param params.runConfig The run config for the context.
   * @returns The new invocation context.
   * @private
   */
  private async _newInvocationContext(params: {
    session: Session;
    newMessage?: Content;
    liveRequestQueue?: LiveRequestQueue;
    runConfig?: RunConfig;
  }): Promise<InvocationContext> {
    const { session, newMessage, liveRequestQueue, runConfig = new RunConfig() } = params;
    
    const invocationId = uuidv4();
    
    // Get the LLM model to use
    let llm: BaseLlm | undefined;
    if (this.agent instanceof LlmAgent) {
      try {
        llm = this.agent.canonicalModel;
      } catch (error) {
        console.error('Error getting canonicalModel:', error);
      }
    }

    // Create context with the model set
    const context = new InvocationContext({
      artifactService: this.artifactService,
      sessionService: this.sessionService,
      memoryService: this.memoryService,
      invocationId: invocationId,
      agent: this.agent,
      session: session,
      userContent: newMessage,
      liveRequestQueue: liveRequestQueue,
      runConfig: runConfig,
      llm: llm
    });

    if (runConfig.supportCfc && this.agent instanceof LlmAgent) {
      // Get the agent's model name using canonicalModel
      const llmAgent = this.agent as LlmAgent;
      const modelName = llmAgent.canonicalModel.model || 'unknown';
      
      if (!modelName.startsWith('gemini-2')) {
        throw new Error(
          `CFC is not supported for model: ${modelName} in agent: ${this.agent.name}`
        );
      }
      
      // Check if built-in code execution tool is already included
      const ctx = new ReadonlyContext(context);
      const resolvedTools = await llmAgent.canonicalTools(ctx);
      const hasCodeExecutionTool = resolvedTools.some(
        (tool: any) => tool instanceof BuiltInCodeExecutionTool
      );
      
      if (!hasCodeExecutionTool) {
        // Add the built-in code execution tool
        llmAgent.tools.push(new BuiltInCodeExecutionTool());
      }
    }

    // Debug log if model is missing
    if (!context.llm) {
      console.warn(`No LLM model set in invocation context for agent: ${this.agent.name}`);
    }

    return context;
  }

  /**
   * Creates a new invocation context for live multi-agent.
   *
   * @param params The parameters for the invocation context.
   * @param params.session The session for the context.
   * @param params.liveRequestQueue The live request queue for the context.
   * @param params.runConfig The run config for the context.
   * @returns The new invocation context.
   * @private
   */
  private async _newInvocationContextForLive(params: {
    session: Session;
    liveRequestQueue?: LiveRequestQueue;
    runConfig?: RunConfig;
  }): Promise<InvocationContext> {
    const { session, liveRequestQueue, runConfig = new RunConfig() } = params;
    
    // For live multi-agent, we need model's text transcription as context for
    // next agent
    if (this.agent.subAgents && this.agent.subAgents.length > 0 && liveRequestQueue) {
      if (!runConfig.responseModalities || runConfig.responseModalities.length === 0) {
        // default
        runConfig.responseModalities = ['AUDIO'];
        if (!runConfig.outputAudioTranscription) {
          runConfig.outputAudioTranscription = {};
        }
      } else if (!runConfig.responseModalities.includes('TEXT')) {
        if (!runConfig.outputAudioTranscription) {
          runConfig.outputAudioTranscription = {};
        }
      }
    }
    
    return this._newInvocationContext({
      session,
      liveRequestQueue,
      runConfig
    });
  }
}

/**
 * An in-memory Runner for testing and development.
 *
 * This runner uses in-memory implementations for artifact, session, and memory
 * services, providing a lightweight and self-contained environment for agent
 * execution.
 */
export class InMemoryRunner extends Runner {
  /**
   * Initializes the InMemoryRunner.
   *
   * @param agent The root agent to run.
   * @param appName The application name of the runner. Defaults to 'InMemoryRunner'.
   */
  constructor(agent: LlmAgent, appName: string = 'InMemoryRunner') {
    super({
      appName: appName,
      agent: agent,
      artifactService: new InMemoryArtifactService(),
      sessionService: new InMemorySessionService(),
      memoryService: new InMemoryMemoryService()
    });
  }
} 